#include "cunit/unit.h"
#include "lib/logfmt.h"

#include "libconfig.h"
#include "sessionid.h"

#include <stdbool.h>
#include <stdint.h>
#include <stdlib.h>

#define DBDIR "test-logfmt-dbdir"

static int set_up(void)
{
    session_clear_id();
    trace_set_id(NULL, 0);
    return 0;
}

static int tear_down(void)
{
    session_clear_id();
    trace_set_id(NULL, 0);
    return 0;
}

static void test_logfmt_escape1(void)
{
    /*
     * Escaping rules are, for now:
     * \x21 \x23-x7E: do not force quoting and remain as is
     *                (except 3D '=' and 5C '\')
     * existing special cases ([\\ \n \r "]) force quoting and become two chars
     * literal space forces quoting and remains space
     * any other character forces quoting and remains self for now
     */
    static const struct {
        const char *value;
        const char *expect;
    } tests[] = {
        { NULL,                 "~null~" },
        { "",                   "\"\"" }, /* empty string is quoted */
        { "basic",              "basic" }, /* basic string isn't quoted */
        { "equals=equals",      "\"equals=equals\"" },
        { "back\\slash",        "\"back\\\\slash\"" },
        { "new\nline",          "\"new\\nline\"" },
        { "carriage\rreturn",   "\"carriage\\rreturn\"" },
        { "double\"quote",      "\"double\\\"quote\"" },
        { " ",                  "\" \"" },
        { "space space",        "\"space space\"" },
        { "tab\ttab",           "\"tab\ttab\"" },
    };
    const size_t n_tests = sizeof(tests) / sizeof(tests[0]);
    unsigned i;

    for (i = 0; i < n_tests; i++) {
        char *actual;

        actual = logfmt_escape(tests[i].value);
        if (tests[i].expect) {
            CU_ASSERT_STRING_EQUAL(actual, tests[i].expect);
        }
        else {
            CU_ASSERT_PTR_NULL(actual);
        }

        free(actual);
    }
}

#define CU_ASSERT_STRING_QUOTED(actual) do {                            \
    const char *_a = (actual);                                          \
    size_t len = strlen(_a);                                            \
    bool is_quoted = len > 0 && _a[0] == '"' && _a[len - 1] == '"';     \
    CU_assertFormatImplementation(is_quoted, __LINE__, __FILE__,        \
        "", CU_FALSE, "CU_ASSERT_STRING_QUOTED(%s=%s)",                 \
        #actual, _a);                                                   \
} while (0)

#define CU_ASSERT_CHAR_ESCAPED(actual, expect) do {                     \
    const char *_a = (actual);                                          \
    int _e = (expect);                                                  \
    bool has_backslash = (_a[0] == '\\');                               \
    bool is_right_char = (_a[1] == _e);                                 \
    CU_assertFormatImplementation(has_backslash && is_right_char,       \
        __LINE__, __FILE__, "", CU_FALSE,                               \
        "CU_ASSERT_CHAR_ESCAPED(%s=\"%.2s\", %s=%x)",                   \
        #actual, _a, #expect, _e);                                      \
} while (0)

static void test_logfmt_escape2(void)
{
    #define EXPECT_QUOTED   (UINT8_C(1) << 0)
    #define EXPECT_ESCAPED  (UINT8_C(1) << 1)
    #define XX              UINT8_C(0)
    #define QX              (EXPECT_QUOTED)
    #define QE              (EXPECT_QUOTED | EXPECT_ESCAPED)
    static const uint8_t lookup[128] = {
    /*  _0  _1  _2  _3  _4  _5  _6  _7  _8  _9  _a  _b  _c  _d  _e  _f       */
        XX, QX, QX, QX, QX, QX, QX, QX, QX, QX, QE, XX, XX, QE, XX, XX, /* 0 */
        XX, QX, QX, XX, QX, QX, QX, QX, QX, QX, QX, QX, QX, QX, QX, QX, /* 1 */
        QX, XX, QE, XX, XX, XX, XX, XX, XX, XX, XX, XX, XX, XX, XX, XX, /* 2 */
        XX, XX, XX, XX, XX, XX, XX, XX, XX, XX, XX, XX, XX, QX, XX, XX, /* 3 */
        XX, XX, XX, XX, XX, XX, XX, XX, XX, XX, XX, XX, XX, XX, XX, XX, /* 4 */
        XX, XX, XX, XX, XX, XX, XX, XX, XX, XX, XX, XX, QE, XX, XX, XX, /* 5 */
        XX, XX, XX, XX, XX, XX, XX, XX, XX, XX, XX, XX, XX, XX, XX, XX, /* 6 */
        XX, XX, XX, XX, XX, XX, XX, XX, XX, XX, XX, XX, XX, XX, XX, QX, /* 7 */
    };
    int n_tests = sizeof(lookup) / sizeof(lookup[0]);
    int i;

    for (i = 1; i < n_tests; i++) {
        const bool expect_quoted = (lookup[i] & EXPECT_QUOTED);
        const bool expect_escaped = (lookup[i] & EXPECT_ESCAPED);
        char value[32], *actual;

        snprintf(value, sizeof(value), "x%cy", i);
        actual = logfmt_escape(value);

        if (expect_quoted) {
            CU_ASSERT_STRING_QUOTED(actual);
        }
        else {
            CU_ASSERT_NOT_EQUAL(actual[0], '"');
        }

        CU_ASSERT_EQUAL(actual[0 + expect_quoted], 'x');

        if (expect_escaped) {
            switch (i) {
            case '\n':
                CU_ASSERT_CHAR_ESCAPED(actual + 1 + expect_quoted, 'n');
                break;
            case '\r':
                CU_ASSERT_CHAR_ESCAPED(actual + 1 + expect_quoted, 'r');
                break;
            default:
                CU_ASSERT_CHAR_ESCAPED(actual + 1 + expect_quoted, i);
                break;
            }
        }
        else {
            CU_ASSERT_NOT_EQUAL(actual[1 + expect_quoted], '\\');
        }

        CU_ASSERT_EQUAL(actual[2 + expect_quoted + expect_escaped], 'y');
        free(actual);
    }
}

static void test_logfmt_push(void)
{
    static const struct {
        const char *event;
        const char *value;
        const char *expect;
    } tests[] = {
        { NULL,    NULL,    "event=~null~ k=~null~"   },
        { NULL,    "",      "event=~null~ k=\"\""     },
        { "",      NULL,    "event=\"\" k=~null~"     },
        { "",      "",      "event=\"\" k=\"\""       },
        { "a",     "b",     "event=a k=b"             },
        { "a",     "\"b\"", "event=a k=\"\\\"b\\\"\"" },
        { "\"a\"", "b",     "event=\"\\\"a\\\"\" k=b" },
    };
    const size_t n_tests = sizeof(tests) / sizeof(tests[0]);
    struct logfmt lf = LOGFMT_INITIALIZER;
    unsigned i;

    for (i = 0; i < n_tests; i++) {
        logfmt_init(&lf, tests[i].event);
        logfmt_push(&lf, "k", tests[i].value);
        CU_ASSERT_STRING_EQUAL(logfmt_cstring(&lf), tests[i].expect);
    }

    logfmt_fini(&lf);
}

static void test_logfmt_pushf(void)
{
    static const struct {
        const char *event;
        const char *value;
        const char *expect;
    } tests[] = {
        { NULL,    "",      "event=~null~ k=\"\""     },
        { "",      "",      "event=\"\" k=\"\""       },
        { "a",     "b",     "event=a k=b"             },
        { "a",     "\"b\"", "event=a k=\"\\\"b\\\"\"" },
        { "\"a\"", "b",     "event=\"\\\"a\\\"\" k=b" },
    };
    const size_t n_tests = sizeof(tests) / sizeof(tests[0]);
    struct logfmt lf = LOGFMT_INITIALIZER;
    unsigned i;

    for (i = 0; i < n_tests; i++) {
        logfmt_init(&lf, tests[i].event);
        logfmt_pushf(&lf, "k", "%s", tests[i].value);
        CU_ASSERT_STRING_EQUAL(logfmt_cstring(&lf), tests[i].expect);
    }

    logfmt_fini(&lf);
}

static void test_logfmt_push_session(void)
{
    static const struct {
        bool with_session_id;
        bool with_trace_id;
    } tests[] = {
        { false, false },
        { false, true  },
        { true,  false },
        { true,  true },
    };
    const size_t n_tests = sizeof(tests) / sizeof(tests[0]);
    struct logfmt lf = LOGFMT_INITIALIZER;
    unsigned i;

    /* need basic configuration for session_new_id() */
    config_read_string(
        "configdirectory: "DBDIR"/conf\n"
    );

    for (i = 0; i < n_tests; i++) {
        char match[32 + MAX_SESSIONID_SIZE] = {0};

        if (tests[i].with_session_id) {
            session_new_id();
            snprintf(match, sizeof(match), " sessionid=%s ", session_id());
        }

        if (tests[i].with_trace_id) {
            trace_set_id("sometraceid", 0);
        }

        logfmt_init(&lf, "test_logfmt_push_session");
        logfmt_push_session(&lf);
        logfmt_push(&lf, "key", "value");

        if (tests[i].with_session_id)
            CU_ASSERT_PTR_NOT_NULL(strstr(logfmt_cstring(&lf), match));
        else
            CU_ASSERT_PTR_NULL(strstr(logfmt_cstring(&lf), " sessionid="));

        if (tests[i].with_trace_id)
            CU_ASSERT_PTR_NOT_NULL(strstr(logfmt_cstring(&lf),
                                          " r.tid=sometraceid "));
        else
            CU_ASSERT_PTR_NULL(strstr(logfmt_cstring(&lf), " r.tid="));

        logfmt_fini(&lf);
        session_clear_id();
        trace_set_id(NULL, 0);
    }
}

/* vim: set ft=c: */
