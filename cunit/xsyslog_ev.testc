#include "cunit/unit.h"
#include "lib/util.h"

#include "lib/libconfig.h"
#include "lib/logfmt.h"
#include "lib/sessionid.h"

#include <syslog.h>
#include <limits.h>
#include <errno.h>

#define DBDIR "test-xsyslogev-dbdir"

static int set_up(void)
{
    session_clear_id();
    trace_set_id(NULL, 0);
    return 0;
}

static int tear_down(void)
{
    session_clear_id();
    trace_set_id(NULL, 0);
    return 0;
}

static void test_lf_c(void)
{
    char third = 'c';

    CU_SYSLOG_MATCH("event=\"lf_c test\" first=a second=b third=c");
    xsyslog_ev(LOG_ERR, "lf_c test",
        lf_c("first", 'a'), lf_c("second", 'b'), lf_c("third", third));
    CU_ASSERT_SYSLOG(/*all*/0, 1);
}

static void test_lf_d(void)
{
    int third = -56;

    CU_SYSLOG_MATCH("event=\"lf_d test\" first=12 second=-34 third=-56");
    xsyslog_ev(LOG_ERR, "lf_d test",
        lf_d("first", 12), lf_d("second", -34), lf_d("third", third));
    CU_ASSERT_SYSLOG(/*all*/0, 1);
}

static void test_lf_ld(void)
{
    struct buf want = BUF_INITIALIZER;
    buf_printf(&want, "event=\"lf_ld test\" first=12 second=-34 third=%ld",
               LONG_MAX);

    CU_SYSLOG_MATCH(buf_cstring(&want));
    xsyslog_ev(LOG_ERR, "lf_ld test",
        lf_ld("first", 12), lf_ld("second", -34), lf_ld("third", LONG_MAX));
    CU_ASSERT_SYSLOG(/*all*/0, 1);

    buf_free(&want);
}

static void test_lf_lld(void)
{
    struct buf want = BUF_INITIALIZER;
    buf_printf(&want, "event=\"lf_lld test\" first=12 second=-34 third=%lld",
               LLONG_MAX);

    CU_SYSLOG_MATCH(buf_cstring(&want));
    xsyslog_ev(LOG_ERR, "lf_lld test",
        lf_lld("first", 12), lf_lld("second", -34), lf_lld("third", LLONG_MAX));
    CU_ASSERT_SYSLOG(/*all*/0, 1);

    buf_free(&want);
}

static void test_lf_u(void)
{
    int third = 56;

    CU_SYSLOG_MATCH("event=\"lf_u test\" first=12 second=34 third=56");
    xsyslog_ev(LOG_ERR, "lf_u test",
        lf_u("first", 12), lf_u("second", 34), lf_u("third", third));
    CU_ASSERT_SYSLOG(/*all*/0, 1);
}

static void test_lf_lu(void)
{
    struct buf want = BUF_INITIALIZER;
    buf_printf(&want, "event=\"lf_lu test\" first=12 second=34 third=%lu",
               ULONG_MAX);

    CU_SYSLOG_MATCH(buf_cstring(&want));
    xsyslog_ev(LOG_ERR, "lf_lu test",
        lf_lu("first", 12), lf_lu("second", 34), lf_lu("third", ULONG_MAX));
    CU_ASSERT_SYSLOG(/*all*/0, 1);

    buf_free(&want);
}

static void test_lf_llu(void)
{
    struct buf want = BUF_INITIALIZER;
    buf_printf(&want, "event=\"lf_llu test\" first=12 second=34 third=%llu",
               ULLONG_MAX);

    CU_SYSLOG_MATCH(buf_cstring(&want));
    xsyslog_ev(LOG_ERR, "lf_llu test",
        lf_llu("first", 12), lf_llu("second", 34), lf_llu("third", ULLONG_MAX));
    CU_ASSERT_SYSLOG(/*all*/0, 1);

    buf_free(&want);
}

static void test_lf_zd(void)
{
    ssize_t third = -56;

    CU_SYSLOG_MATCH("event=\"lf_zd test\" first=12 second=34 third=-56");
    xsyslog_ev(LOG_ERR, "lf_zd test",
        lf_zd("first", 12), lf_zd("second", 34), lf_zd("third", third));
    CU_ASSERT_SYSLOG(/*all*/0, 1);
}

static void test_lf_zu(void)
{
    size_t third = 56;

    CU_SYSLOG_MATCH("event=\"lf_zu test\" first=12 second=34 third=56");
    xsyslog_ev(LOG_ERR, "lf_zu test",
        lf_zu("first", 12), lf_zu("second", 34), lf_zu("third", third));
    CU_ASSERT_SYSLOG(/*all*/0, 1);
}

static void test_lf_llx(void)
{
    size_t third = 15;

    CU_SYSLOG_MATCH("event=\"lf_llx test\" first=1 second=A third=F");
    xsyslog_ev(LOG_ERR, "lf_llx test",
        lf_llx("first", 1), lf_llx("second", 10), lf_llx("third", third));
    CU_ASSERT_SYSLOG(/*all*/0, 1);
}

static void test_lf_f(void)
{
    double third = 3.3;

    CU_SYSLOG_MATCH("event=\"lf_f test\" first=1\\.10* second=2\\.20* third=3\\.30*");
    xsyslog_ev(LOG_ERR, "lf_f test",
        lf_f("first", 1.1), lf_f("second", 2.2), lf_f("third", third));
    CU_ASSERT_SYSLOG(/*all*/0, 1);
}

static void test_lf_s(void)
{
    const char *third = "three";

    // simple
    CU_SYSLOG_MATCH("event=\"lf_s test\" first=one second=two third=three");
    xsyslog_ev(LOG_ERR, "lf_s test",
        lf_s("first", "one"), lf_s("second", "two"), lf_s("third", third));
    CU_ASSERT_SYSLOG(/*all*/0, 1);

    // empty string
    CU_SYSLOG_MATCH("event=\"lf_s test\" first=\"\"");
    xsyslog_ev(LOG_ERR, "lf_s test", lf_s("first", ""));
    CU_ASSERT_SYSLOG(/*all*/0, 1);

    // spaces
    CU_SYSLOG_MATCH("event=\"lf_s test\" first=\"with spaces\"");
    xsyslog_ev(LOG_ERR, "lf_s test", lf_s("first", "with spaces"));
    CU_ASSERT_SYSLOG(/*all*/0, 1);

    // tabs
    CU_SYSLOG_MATCH("event=\"lf_s test\" first=\"with\\\\ttabs\"");
    xsyslog_ev(LOG_ERR, "lf_s test", lf_s("first", "with\ttabs"));
    CU_ASSERT_SYSLOG(/*all*/0, 1);

    // quotes
    CU_SYSLOG_MATCH("event=\"lf_s test\" first=\"\\\\\"quotes\\\\\"\"");
    xsyslog_ev(LOG_ERR, "lf_s test", lf_s("first", "\"quotes\""));
    CU_ASSERT_SYSLOG(/*all*/0, 1);

    // \r and \n
    CU_SYSLOG_MATCH("event=\"lf_s test\" first=\"\\\\r\\\\n\"");
    xsyslog_ev(LOG_ERR, "lf_s test", lf_s("first", "\r\n"));
    CU_ASSERT_SYSLOG(/*all*/0, 1);

    // =
    CU_SYSLOG_MATCH("event=\"lf_s test\" first=\"=\"");
    xsyslog_ev(LOG_ERR, "lf_s test", lf_s("first", "="));
    CU_ASSERT_SYSLOG(/*all*/0, 1);

    // backslashes
    CU_SYSLOG_MATCH("event=\"lf_s test\" first=\"\\\\\\\\\"");
    xsyslog_ev(LOG_ERR, "lf_s test", lf_s("first", "\\"));
    CU_ASSERT_SYSLOG(/*all*/0, 1);

    // null
    CU_SYSLOG_MATCH("event=\"lf_s test\" first=~null~");
    xsyslog_ev(LOG_ERR, "lf_s test", lf_s("first", NULL));
    CU_ASSERT_SYSLOG(/*all*/0, 1);

    // no quoting or escaping
    struct buf str = BUF_INITIALIZER;
    int iter;
    buf_setcstr(&str, "\x21");

    // okchr = %x21 / %x23-3c / %x3e-5b / %x5d-7e ; graphic ASCII, less: \ " = DEL
    for (iter = 0x21; iter <= 0x7E; iter++) {
        if (iter == 0x22 || iter == 0x3D || iter == 0x5C)
            continue;
        buf_printf(&str, "%c", iter);
    }

    struct buf want = BUF_INITIALIZER;
    buf_printf(&want, "event=\"lf_s test\" first=%s", buf_cstring(&str));

    CU_SYSLOG_MATCH_SUBSTR(buf_cstring(&want));
    xsyslog_ev(LOG_ERR, "lf_s test", lf_s("first", buf_cstring(&str)));
    CU_ASSERT_SYSLOG(/*all*/0, 1);

    buf_free(&want);
    buf_free(&str);

    // in a "bytestring" eightbits are quoted like control chars
    CU_SYSLOG_MATCH("event=\"lf_s test\" build=\"\\\\x\\{e2}\\\\x\\{98}\\\\x\\{83}\"");
    xsyslog_ev(LOG_ERR, "lf_s test", lf_s("build", "☃"));
    CU_ASSERT_SYSLOG(/*all*/0, 1);
}

static void test_lf_utf8(void)
{
    const char *third = "three";

    // simple
    CU_SYSLOG_MATCH("event=\"lf_utf8 test\" first=one second=two third=three");
    xsyslog_ev(LOG_ERR, "lf_utf8 test",
        lf_utf8("first", "one"), lf_utf8("second", "two"), lf_utf8("third", third));
    CU_ASSERT_SYSLOG(/*all*/0, 1);

    // empty string
    CU_SYSLOG_MATCH("event=\"lf_utf8 test\" first=\"\"");
    xsyslog_ev(LOG_ERR, "lf_utf8 test", lf_utf8("first", ""));
    CU_ASSERT_SYSLOG(/*all*/0, 1);

    // spaces
    CU_SYSLOG_MATCH("event=\"lf_utf8 test\" first=\"with spaces\"");
    xsyslog_ev(LOG_ERR, "lf_utf8 test", lf_utf8("first", "with spaces"));
    CU_ASSERT_SYSLOG(/*all*/0, 1);

    // tabs
    CU_SYSLOG_MATCH("event=\"lf_utf8 test\" first=\"with\\\\ttabs\"");
    xsyslog_ev(LOG_ERR, "lf_utf8 test", lf_utf8("first", "with\ttabs"));
    CU_ASSERT_SYSLOG(/*all*/0, 1);

    // quotes
    CU_SYSLOG_MATCH("event=\"lf_utf8 test\" first=\"\\\\\"quotes\\\\\"\"");
    xsyslog_ev(LOG_ERR, "lf_utf8 test", lf_utf8("first", "\"quotes\""));
    CU_ASSERT_SYSLOG(/*all*/0, 1);

    // \r and \n
    CU_SYSLOG_MATCH("event=\"lf_utf8 test\" first=\"\\\\r\\\\n\"");
    xsyslog_ev(LOG_ERR, "lf_utf8 test", lf_utf8("first", "\r\n"));
    CU_ASSERT_SYSLOG(/*all*/0, 1);

    // =
    CU_SYSLOG_MATCH("event=\"lf_utf8 test\" first=\"=\"");
    xsyslog_ev(LOG_ERR, "lf_utf8 test", lf_utf8("first", "="));
    CU_ASSERT_SYSLOG(/*all*/0, 1);

    // backslashes
    CU_SYSLOG_MATCH("event=\"lf_utf8 test\" first=\"\\\\\\\\\"");
    xsyslog_ev(LOG_ERR, "lf_utf8 test", lf_utf8("first", "\\"));
    CU_ASSERT_SYSLOG(/*all*/0, 1);

    // null
    CU_SYSLOG_MATCH("event=\"lf_utf8 test\" first=~null~");
    xsyslog_ev(LOG_ERR, "lf_utf8 test", lf_utf8("first", NULL));
    CU_ASSERT_SYSLOG(/*all*/0, 1);

    // no quoting or escaping
    struct buf str = BUF_INITIALIZER;
    int iter;
    buf_setcstr(&str, "\x21");

    // okchr = %x21 / %x23-3c / %x3e-5b / %x5d-7e ; graphic ASCII, less: \ " = DEL
    for (iter = 0x21; iter <= 0x7E; iter++) {
        if (iter == 0x22 || iter == 0x3D || iter == 0x5C)
            continue;
        buf_printf(&str, "%c", iter);
    }

    struct buf want = BUF_INITIALIZER;
    buf_printf(&want, "event=\"lf_utf8 test\" first=%s", buf_cstring(&str));

    CU_SYSLOG_MATCH_SUBSTR(buf_cstring(&want));
    xsyslog_ev(LOG_ERR, "lf_utf8 test", lf_utf8("first", buf_cstring(&str)));
    CU_ASSERT_SYSLOG(/*all*/0, 1);

    buf_free(&want);
    buf_free(&str);

    // non-special utf8 allowed as is
    CU_SYSLOG_MATCH("event=\"lf_utf8 test\" build=\"☃\"");
    xsyslog_ev(LOG_ERR, "lf_utf8 test", lf_utf8("build", "☃"));
    CU_ASSERT_SYSLOG(/*all*/0, 1);
}

static void test_lf_raw(void)
{
    CU_SYSLOG_MATCH("event=\"lf_raw test\" first=3.14 second=what");
    xsyslog_ev(LOG_ERR, "lf_raw test",
        lf_raw("first", "%.02f", 3.14159), lf_raw("second", "%s", "what"));
    CU_ASSERT_SYSLOG(/*all*/0, 1);
}

static void test_mixed(void)
{
    CU_SYSLOG_MATCH("event=\"mixed test\" first=1 second=2.1 third=\"hi there\"");
    xsyslog_ev(LOG_ERR, "mixed test",
        lf_d("first", 1),
        lf_raw("second", "%.01f", 2.1),
        lf_s("third", "hi there")
    );
    CU_ASSERT_SYSLOG(/*all*/0, 1);
}

static void test_session_id(void)
{
    char match[32 + MAX_SESSIONID_SIZE];

    /* need basic configuration for session_new_id() */
    config_read_string(
        "configdirectory: "DBDIR"/conf\n"
    );

    session_new_id();
    snprintf(match, sizeof(match), " sessionid=%s ", session_id());

    CU_SYSLOG_MATCH_SUBSTR(match);
    xsyslog_ev(LOG_ERR, "session id test",
                        lf_d("first", 1));
    CU_ASSERT_SYSLOG(/*all*/0, 1);

    config_reset();
    system("rm -rf " DBDIR);
}

static void test_trace_id(void)
{
    trace_set_id("sometraceid", 0);

    CU_SYSLOG_MATCH_SUBSTR(" r.tid=sometraceid ");
    xsyslog_ev(LOG_ERR, "trace id test",
                        lf_d("first", 1));
    CU_ASSERT_SYSLOG(/*all*/0, 1);
}

static int mess_with_errno(void)
{
    errno = errno + 1;

    return 1;
}

static void test_syserror(void)
{
    struct buf expect = BUF_INITIALIZER;
    struct buf errbuf = BUF_INITIALIZER;
    unsigned pat_a = 0, pat_b = 0, pat_syserror = 0;
    const int test_errno = 1;

    // escape expected error string if necessary...
    logfmt_escape_bytestring(&errbuf, strerror(test_errno));
    buf_printf(&expect, "sys.error=%s", buf_cstring(&errbuf));

    pat_a = CU_SYSLOG_MATCH_SUBSTR("a=1");
    pat_b = CU_SYSLOG_MATCH_SUBSTR("b=1");
    pat_syserror = CU_SYSLOG_MATCH_SUBSTR(buf_cstring(&expect));

    errno = test_errno;
    xsyslog_ev(LOG_ERR, "syserror test",
               lf_d("a", mess_with_errno()),
               lf_d("b", mess_with_errno())
    );
    CU_ASSERT_SYSLOG(pat_a, 1);
    CU_ASSERT_SYSLOG(pat_b, 1);
    CU_ASSERT_SYSLOG(pat_syserror, 1);

    buf_free(&errbuf);
    buf_free(&expect);
}

/* vim: set ft=c: */
