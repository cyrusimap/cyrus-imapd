#include <sys/types.h>
#include <sys/stat.h>

#include <errno.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>

#include "cunit/cyrunit.h"
#include "lib/util.h"
#include "lib/strhash.h"

extern int verbose;

static const char *repeat(int c, unsigned n)
{
    static char buf[1024];
    char *p = buf;

    /* always leave room for a \0 */
    if (n >= sizeof(buf))
        n = sizeof(buf) - 1;

    memset(buf, 0, sizeof(buf));
    while (n--) {
        *p++ = c;
    }

    return buf;
}

static void test_repeated(void)
{
    /* repeated chars on the end should not obliterate earlier input */
    unsigned suffix_lengths[] = { 15, 31, 63, 127, 255, 511, 1023 };
    unsigned i;

    for (i = 0; i < sizeof(suffix_lengths) / sizeof(suffix_lengths[0]); i++) {
        char *cat = strconcat("cat", repeat('a', suffix_lengths[i]), NULL);
        char *dog = strconcat("dog", repeat('a', suffix_lengths[i]), NULL);
        char *mouse = strconcat("mouse", repeat('a', suffix_lengths[i]), NULL);

        unsigned xcat = strhash(cat);
        unsigned xdog = strhash(dog);
        unsigned xmouse = strhash(mouse);

        CU_ASSERT_NOT_EQUAL(xcat, xdog);
        CU_ASSERT_NOT_EQUAL(xdog, xmouse);
        CU_ASSERT_NOT_EQUAL(xmouse, xcat);

        free(cat);
        free(dog);
        free(mouse);
    }
}

static void test_seeded(void)
{
    const char *const words[] = { "lorem", "ipsum", "dolor", "sit", "amet" };
    const size_t n_words = sizeof(words) / sizeof(words[0]);
    unsigned hashes[n_words];
    unsigned i, j;

    memset(hashes, 0, sizeof(hashes));

    /* with no seed, same input should produce same hash */
    for (i = 0; i < n_words; i++) {
        unsigned h1 = strhash(words[i]);
        unsigned h2 = strhash(words[i]);
        CU_ASSERT_EQUAL(h1, h2);
    }

    /* with explicit zero seed, same input should produce same hash */
    for (i = 0; i < n_words; i++) {
        unsigned h1 = strhash(words[i]);
        unsigned h2 = strhash_seeded(0, words[i]);
        unsigned h3 = strhash_seeded(0, words[i]);
        CU_ASSERT_EQUAL(h1, h2);
        CU_ASSERT_EQUAL(h2, h3);
        CU_ASSERT_EQUAL(h3, h1);
    }

    /* with some seed, same input should produce same hash */
    for (j = 0; j < 5; j++) {
        uint32_t seed;
        do {
            seed = rand();
        } while (seed == 0);

        for (i = 0; i < n_words; i++) {
            unsigned h1 = strhash_seeded(seed, words[i]);
            unsigned h2 = strhash_seeded(seed, words[i]);
            CU_ASSERT_EQUAL(h1, h2);
        }
    }

    /* with different seed, same input should produce different hash */
    for (i = 0; i < n_words; i++) {
        uint32_t seed1, seed2;
        do {
            seed1 = rand();
            seed2 = rand();
        } while (seed1 == 0 || seed2 == 0 || seed1 == seed2);

        unsigned h1 = strhash_seeded(seed1, words[i]);
        unsigned h2 = strhash_seeded(seed2, words[i]);

        CU_ASSERT_NOT_EQUAL(h1, h2);
    }
}

/* vim: set ft=c: */
