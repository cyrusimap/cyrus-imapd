#!/usr/bin/perl
#
# compile_st.pl - compile string table into .h and .c files
#
# Copyright (c) 1994-2010 Carnegie Mellon University.  All rights reserved.
#
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions
# are met:
#
# 1. Redistributions of source code must retain the above copyright
#    notice, this list of conditions and the following disclaimer.
#
# 2. Redistributions in binary form must reproduce the above copyright
#    notice, this list of conditions and the following disclaimer in
#    the documentation and/or other materials provided with the
#    distribution.
#
# 3. The name "Carnegie Mellon University" must not be used to
#    endorse or promote products derived from this software without
#    prior written permission. For permission or any legal
#    details, please contact
#      Carnegie Mellon University
#      Center for Technology Transfer and Enterprise Creation
#      4615 Forbes Avenue
#      Suite 302
#      Pittsburgh, PA  15213
#      (412) 268-7393, fax: (412) 268-7395
#      innovation@andrew.cmu.edu
#
# 4. Redistributions of any form whatsoever must retain the following
#    acknowledgment:
#    "This product includes software developed by Computing Services
#     at Carnegie Mellon University (http://www.cmu.edu/computing/)."
#
# CARNEGIE MELLON UNIVERSITY DISCLAIMS ALL WARRANTIES WITH REGARD TO
# THIS SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
# AND FITNESS, IN NO EVENT SHALL CARNEGIE MELLON UNIVERSITY BE LIABLE
# FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
# WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN
# AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING
# OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
#

use strict;
use warnings;

my $c_flag = 0;
my $h_flag = 0;
my $infile;

sub usage()
{
    print STDERR "Usage: compile_st.pl -c input.st | gperf > output.c\n";
    print STDERR "       compile_st.pl -h input.st > output.h\n";
    exit 1;
}

while (my $a = shift)
{
    if ($a eq "-c")
    {
	$c_flag = 1;
    }
    elsif ($a eq "-h")
    {
	$h_flag = 1;
    }
    elsif ($a eq "--help")
    {
	usage();
    }
    elsif ($a =~ m/^-/)
    {
	usage();
    }
    else
    {
	usage()
	    if defined $infile;
	$infile = $a;
    }
}

usage()
    unless defined $infile;

die "Please specify exactly one of -c or -h"
    unless ($c_flag + $h_flag == 1);

# variables containing the logical contents of the string table file
my @gperf_directives = (
    "includes",
    "compare-strncmp",
    "language=ANSI-C",
    "readonly-tables",
    "struct-type"
);
my $name;
my $unknown;
my $next_unknown = -1;
my $next_known = 0;
my @entries;

#
# Slurp the .st stringtab file into variables.
#

open ST,'<',$infile
    or die "Cannot open $infile for reading: $!";
while (<ST>)
{
    chomp;
    next if m/^\s*#/;	    # skip comments
    next if m/^\s*$/;	    # skip empty lines
    my @a = split;

    if ($a[0] eq "%ignore-case" && scalar(@a) == 1)
    {
	push(@gperf_directives, "ignore-case");
    }
    elsif ($a[0] =~ m/^%/)
    {
	die "Unrecognised gperf declaration \"$_\"";
    }
    elsif ($a[0] eq "table")
    {
	die "Wrong number of arguments for \"table\""
	    unless scalar(@a) == 2;
	$name = $a[1];
    }
    elsif ($a[0] eq "ent")
    {
	my $enum;
	my $string;
	my $value;

	($enum) = m/^\s*ent\s+([A-Za-z_][A-Za-z_0-9]*)\s*$/;
	if (!defined $enum)
	{
	    ($enum, $string) = m/^\s*ent\s+([A-Za-z_][A-Za-z_0-9]*)\s+"([^"]+)"\s*$/;
	    die "Bad syntax for \"ent\" at or near \"$_\""
		unless defined $string;
	}

	if (!defined $string)
	{
	    $value = $next_unknown;
	    $next_unknown--;
	    $unknown = $enum
		unless defined $unknown;
	}
	else
	{
	    $value = $next_known;
	    $next_known++;
	}

	push(@entries, { enum => $enum, value => $value, string => $string });
    }
    else
    {
	die "Unrecognised keyword at or near \"$_\"";
    }
}
close ST;

die "No table name defined in $infile"
    unless defined $name;
die "No string entries defined"
    unless scalar(@entries) > 0;
$unknown = "-1"
    unless defined $unknown;

# Emit the C header file is requested
if ($h_flag)
{
    printf "/* Automatically generated by compile_st.pl, do not edit */\n";
    printf "#ifndef __STRING_TABLE_%s_H_\n", $name;
    printf "#define __STRING_TABLE_%s_H_ 1\n", $name;
    printf "\n";
    printf "#include <string.h>\n";
    printf "\n";

    printf "enum %s {\n", $name;
    foreach my $e (@entries)
    {
	printf "    %s", $e->{enum};
	printf "=%d", $e->{value}
	    if defined $e->{value};
	printf ",\n"
    }
    printf "};\n";

    printf "extern enum %s %s_from_string(const char *s);\n", $name, $name;
    printf "extern enum %s %s_from_string_len(const char *s, size_t len);\n", $name, $name;
    printf "extern const char *%s_to_string(enum %s v);\n", $name, $name;

    printf "\n";
    printf "#endif /* __STRING_TABLE_%s_H_ */\n", $name;
}

# Emit the gperf source file if requested
if ($c_flag)
{
    printf "%%define lookup-function-name __%s_lookup\n", $name;
    foreach my $d (@gperf_directives)
    {
	printf "%%%s\n", $d;
    }

    printf "%%{\n";
    printf "/* Automatically generated by compile_st.pl, do not edit */\n";
    printf "#include \"%s.h\"\n", $name;
    printf "%%}\n";

    printf "struct %s_desc { const char *name; enum %s value; };\n", $name, $name;
    printf "%%%%\n";

    foreach my $e (@entries)
    {
	next unless defined $e->{string};
	printf "%s, %s\n", $e->{string}, $e->{enum};
    }

    printf "%%%%\n";

    printf "enum %s %s_from_string(const char *s)\n", $name, $name;
    printf "{\n";
    printf "    const struct %s_desc *d = __%s_lookup(s, strlen(s));\n", $name, $name;
    printf "    return (d == NULL ? %s : d->value);\n", $unknown;
    printf "}\n";
    printf "\n";
    printf "enum %s %s_from_string_len(const char *s, size_t len)\n", $name, $name;
    printf "{\n";
    printf "    const struct %s_desc *d = __%s_lookup(s, len);\n", $name, $name;
    printf "    return (d == NULL ? %s : d->value);\n", $unknown;
    printf "}\n";
    printf "\n";
    printf "const char *%s_to_string(enum %s v)\n", $name, $name;
    printf "{\n";
    printf "    static const char * const strs[] = {\n";
    foreach my $e (@entries)
    {
	next unless defined $e->{string};
	printf "\t\"%s\", /* %s */\n", $e->{string}, $e->{enum};
    }
    printf "    };\n";
    printf "    return (v >= 0 && v < sizeof(strs)/sizeof(strs[0]) ? strs[v] : NULL);\n";
    printf "}\n";
}

