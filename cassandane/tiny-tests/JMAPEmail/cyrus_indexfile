#!perl
use Cassandane::Tiny;
use Cyrus::IndexFile;

# This tests both a bit of the interface of Cyrus::IndexFile and also that
# cyrus itself is writing out index files correctly according to the
# definitions Cyrus::IndexFile expects - to make sure that Cyrus itself isn't
# writing/reading incorrect index files consistently.
sub test_cyrus_indexfile
    :needs_component_sieve
{
    my ($self) = @_;
    my $jmap = $self->{jmap};

    my $res = $jmap->CallMethods([[
        'Mailbox/set' => {
            create => {
                "1" => {
                    name     => "foo",
                },
            },
        }, "a",
    ]]);

    $self->assert_str_equals('Mailbox/set', $res->[0][0]);

    my $mailbox_id = $res->[0][1]{created}{1}{id};
    $self->assert_not_null($mailbox_id);

    my $created_modseq = $res->[0][1]{newState};
    $self->assert_not_null($created_modseq);

    # Our base assumptions. Will be overridden below as things change
    my %expect = (
        Answered          => 0,
        Deleted           => 0,
        DeletedModseq     => 0,
        Exists            => 0,
        FirstExpunged     => 0,
        Flagged           => 0,
        Format            => 0,
        Generation        => 0,
        LastAppenddate    => 0,
        LastCleanup       => 0,
        LastUid           => 0,
        LeakedCache       => 0,
        MinorVersion      => Cyrus::IndexFile->latest_version,
        NumRecords        => 0,
        Options           => '00000000000000000000000000000001',
        Pop3LastLogin     => 0,
        Pop3ShowAfter     => 0,
        QuotaAnnotUsed    => 0,
        QuotaDeletedUsed  => 0,
        QuotaExpungedUsed => 0,
        QuotaUsed         => 0,
        RecentTime        => 0,
        RecentUid         => 0,
        Unseen            => 0,
    );

    xlog $self, "Checking index for newly created folder";
    {
        my $index = $self->index_file_for('user.cassandane.foo');

        my $hh = $index->header_copy;

        # These must be computed or discovered. XXX
        delete $hh->{$_} for qw(
            ChangesEpoch
            HeaderCrc 
            HeaderFileCRC
            RecordSize
            StartOffset
            SyncCRCsAnnot
            SyncCRCsBasic
        );

        # Trust imap I guess
        my $talk = $self->{store}->get_client();
        $talk->select("foo");

        # XXX - Assert this more strictly
        my $highest_modseq = $talk->get_response_code('highestmodseq');
        $self->assert_not_null($highest_modseq);

        # XXX - Assert this more strictly
        my $uidvalidity = $talk->get_response_code('uidvalidity');
        $self->assert_not_null($uidvalidity);

        $self->assert_deep_equals(
            {
                %expect,
                CreatedModseq => $created_modseq,
                HighestModseq => $highest_modseq,
                UidValidity   => $uidvalidity,
            },
            $hh,
        );

        my $rec = $index->next_record;
        $self->assert_null($rec, 'no records yet');
    }

    xlog $self, "Appending a message then checking again";

    $self->{store}->set_folder('foo');
    my $msg = $self->make_message('A message');

    $res = $jmap->CallMethods([
        [
            'Email/query' => {
                filter => {
                    inMailbox => $mailbox_id,
                },
            }, 'a',
        ], [
            'Email/get' => {
                '#ids' => {
                    resultOf => 'a',
                    name     => 'Email/query',
                    path     => '/ids',
                },
            }, 'b',
        ],
    ]);

    my $email_id = $res->[0][1]{ids}[0];
    $self->assert_not_null($email_id);

    my $cid = $res->[1][1]{list}[0]{threadId} =~ s/^T//r;
    $self->assert_not_null($cid);

    my $guid = $res->[1][1]{list}[0]{blobId} =~ s/^G//r;
    $self->assert_not_null($guid);

    xlog $self, "Checking index for newly created message";
    {
        my $index = $self->index_file_for('user.cassandane.foo');

        my $hh = $index->header_copy;

        # These must be computed or discovered. XXX
        delete $hh->{$_} for qw(
            ChangesEpoch
            HeaderCrc 
            HeaderFileCRC
            RecordSize
            StartOffset
            SyncCRCsAnnot
            SyncCRCsBasic

            LastAppenddate
            RecentTime
        );

        # Trust imap I guess
        $self->{store}->disconnect;

        my $talk = $self->{store}->get_client();
        $talk->select("foo");

        # XXX - Assert this more strictly
        my $highest_modseq = $talk->get_response_code('highestmodseq');
        $self->assert_not_null($highest_modseq);

        # XXX - Assert this more strictly
        my $uidvalidity = $talk->get_response_code('uidvalidity');
        $self->assert_not_null($uidvalidity);

        delete local $expect{LastAppenddate};
        delete local $expect{RecentTime};

        $self->assert_deep_equals(
            {
                %expect,
                CreatedModseq => $created_modseq,
                HighestModseq => $highest_modseq,
                UidValidity   => $uidvalidity,

                LastUid       => 1,
                RecentUid     => 1,
                Exists        => 1,
                NumRecords    => 1,
                Unseen        => 1,
                QuotaUsed     => length $msg->as_string,
            },
            $hh,
        );

        my @recs;
        while (my $rec = $index->next_record) {
            $rec->{SystemFlags} = {
                map {
                    $_ => 1,
                } keys %{ $index->system_flags }
            };

            push @recs, $rec;
        }

        $self->assert_num_equals(1, 0+@recs, 'we have 1 record');

        my $rec = $recs[0];

        delete $rec->{$_} for qw(
            CacheCrc
            CacheOffset
            CacheVersion
            GmTime
            HeaderSize
            InternalDate
            LastUpdated
            RecordCrc
            SaveDate
            SentDate
        );

        $self->assert_deep_equals(
            {
                CID           => $cid,
                CreatedModseq => $created_modseq + 1,
                MessageGuid   => $guid,
                Modseq        => $created_modseq + 1,
                Size          => length $msg->as_string,
                SystemFlags   => {},
                Uid           => 1,
                UserFlags     => '0' x 128,
            },
            $rec,
        );
    }

    xlog $self, "Marking a message answered then checking again";
    $res = $jmap->CallMethods([[
        "Email/set" => {
            update => {
                $email_id => {
                    keywords => {
                        '$seen' => JSON::true,
                    },
                },
            },
        }, 'a',
    ]]);

    $self->assert_not_null($res->[0][1]{updated});

    {
        my $index = $self->index_file_for('user.cassandane.foo');

        my $hh = $index->header_copy;

        # These must be computed or discovered. XXX
        delete $hh->{$_} for qw(
            ChangesEpoch
            HeaderCrc 
            HeaderFileCRC
            RecordSize
            StartOffset
            SyncCRCsAnnot
            SyncCRCsBasic

            LastAppenddate
            RecentTime
        );

        # Trust imap I guess
        $self->{store}->disconnect;

        my $talk = $self->{store}->get_client();
        $talk->select("foo");

        # XXX - Assert this more strictly
        my $highest_modseq = $talk->get_response_code('highestmodseq');
        $self->assert_not_null($highest_modseq);

        # XXX - Assert this more strictly
        my $uidvalidity = $talk->get_response_code('uidvalidity');
        $self->assert_not_null($uidvalidity);

        delete local $expect{LastAppenddate};
        delete local $expect{RecentTime};

        $self->assert_deep_equals(
            {
                %expect,
                CreatedModseq => $created_modseq,
                HighestModseq => $highest_modseq,
                UidValidity   => $uidvalidity,

                LastUid       => 1,
                RecentUid     => 1,
                Exists        => 1,
                NumRecords    => 1,
                QuotaUsed     => length $msg->as_string,

                Unseen        => 0,
            },
            $hh,
        );

        my @recs;
        while (my $rec = $index->next_record) {
            $rec->{SystemFlags} = {
                map {
                    $_ => 1,
                } keys %{ $index->system_flags }
            };

            push @recs, $rec;            
        }

        $self->assert_num_equals(1, 0+@recs, 'we have 1 record');

        my $rec = $recs[0];

        delete $rec->{$_} for qw(
            CacheCrc
            CacheOffset
            CacheVersion
            GmTime
            HeaderSize
            InternalDate
            LastUpdated
            RecordCrc
            SaveDate
            SentDate
        );

        $self->assert_deep_equals(
            {
                CID           => $cid,
                CreatedModseq => $created_modseq + 1,
                MessageGuid   => $guid,
                Modseq        => $created_modseq + 2,
                Size          => length $msg->as_string,
                SystemFlags   => { '\\Seen' => 1 },
                Uid           => 1,
                UserFlags     => '0' x 128,
            },
            $rec,
        );
    }

    xlog $self, "Deleting a message then checking again";
    $res = $jmap->CallMethods([[
        'Email/set' => {
            destroy => [ $email_id ]
        }, 'a',
    ]]);

    $self->assert_str_equals($email_id, $res->[0][1]{destroyed}[0]);

    {
        my $index = $self->index_file_for('user.cassandane.foo');

        my $hh = $index->header_copy;

        # These must be computed or discovered. XXX
        delete $hh->{$_} for qw(
            ChangesEpoch
            HeaderCrc 
            HeaderFileCRC
            RecordSize
            StartOffset
            SyncCRCsAnnot
            SyncCRCsBasic

            LastAppenddate
            RecentTime
        );

        # Trust imap I guess
        $self->{store}->disconnect;

        my $talk = $self->{store}->get_client();
        $talk->select("foo");

        # XXX - Assert this more strictly
        my $highest_modseq = $talk->get_response_code('highestmodseq');
        $self->assert_not_null($highest_modseq);

        # XXX - Assert this more strictly
        my $uidvalidity = $talk->get_response_code('uidvalidity');
        $self->assert_not_null($uidvalidity);

        delete local $expect{LastAppenddate};
        delete local $expect{RecentTime};
        delete local $expect{FirstExpunged};

        my $first_exp = delete $hh->{FirstExpunged};
        my $tdiff = abs(time - $first_exp);

        # Should be a timestamp within the last few seconds
        $self->assert($tdiff <= 3600);

        $self->assert_deep_equals(
            {
                %expect,
                CreatedModseq => $created_modseq,
                HighestModseq => $highest_modseq,
                UidValidity   => $uidvalidity,

                Unseen        => 0,
                LastUid       => 1,
                RecentUid     => 1,
                NumRecords    => 1,

                QuotaUsed     => 0,
                Exists        => 0,
                QuotaExpungedUsed => length $msg->as_string,
            },
            $hh,
        );

        my @recs;
        while (my $rec = $index->next_record) {
            $rec->{SystemFlags} = {
                map {
                    $_ => 1,
                } keys %{ $index->system_flags }
            };

            push @recs, $rec;
        }

        $self->assert_num_equals(1, 0+@recs, 'we have 1 record');

        my $rec = $recs[0];

        delete $rec->{$_} for qw(
            CacheCrc
            CacheOffset
            CacheVersion
            GmTime
            HeaderSize
            InternalDate
            LastUpdated
            RecordCrc
            SaveDate
            SentDate
        );

        $self->assert_deep_equals(
            {
                CID           => $cid,
                CreatedModseq => $created_modseq + 1,
                MessageGuid   => $guid,
                Modseq        => $created_modseq + 3,
                Size          => length $msg->as_string,
                SystemFlags   => {
                    '\\Seen'     => 1,
                    '\\Deleted'  => 1,
                    '[EXPUNGED]' => 1,
                },
                Uid           => 1,
                UserFlags     => '0' x 128,
            },
            $rec,
        );
    }
}

sub index_file_for {
    my ($self, $mailbox) = @_;

    my $dir = $self->{instance}->folder_to_directory($mailbox);
    my $file = "$dir/cyrus.index";
    my $fh = IO::File->new($file, "+<");
    die "NO SUCH FILE $file? ($!)" unless $fh;

    xlog $self, "Reading index of $mailbox ($file)";

    my $index = Cyrus::IndexFile->new($fh, strict_crc => 1);

    xlog $self, "Header: " . $index->header_longdump;

    my $i = 0;

    while (my $rec = $index->next_record) {
        xlog $self, "Record $i: " . $index->record_longdump;

        $i++;
    }

    $index->reset;

    return $index;
}
